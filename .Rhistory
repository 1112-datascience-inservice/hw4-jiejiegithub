choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC1")
),
mainPanel(
plotOutput("pca_plot")
)
)
)
# Define server
server <- function(input, output) {
# Load data
data(iris)
log.ir <- log(iris[, 1:4])
ir.species <- iris[, 5]
# Apply PCA
ir.pca <- prcomp(log.ir, center = TRUE, scale. = TRUE)
# Create plot
output$pca_plot <- renderPlot({
x_var <- match(input$x_var, colnames(log.ir))
y_var <- match(input$y_var, colnames(log.ir))
if (input$pc == "PC1") {
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1, groups = ir.species,
choices = c(1, 2), varname.size = 4)
} else if (input$pc == "PC2") {
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1, groups = ir.species,
choices = c(2, 3), varname.size = 4)
} else if (input$pc == "PC3") {
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1, groups = ir.species,
choices = c(3, 4), varname.size = 4)
} else {
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1, groups = ir.species,
choices = c(1, 3), varname.size = 4)
}
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', legend.position = 'top')
g <- g + xlab(input$x_var) + ylab(input$y_var)
g$data$x[,1] <- log.ir[,x_var]
g$data$x[,2] <- log.ir[,y_var]
print(g)
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(ggbiplot)
# Define UI
ui <- fluidPage(
titlePanel("PCA Visualization"),
sidebarLayout(
sidebarPanel(
selectInput("xpc", "Choose X Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC1"),
selectInput("ypc", "Choose Y Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC2")
),
mainPanel(
plotOutput("pca_plot")
)
)
)
# Define server
server <- function(input, output) {
# Load data
data(iris)
log.ir <- log(iris[, 1:4])
ir.species <- iris[, 5]
# Apply PCA
ir.pca <- prcomp(log.ir, center = TRUE, scale. = TRUE)
# Create plot
output$pca_plot <- renderPlot({
x_index <- match(input$xpc, c("PC1", "PC2", "PC3", "PC4"))
y_index <- match(input$ypc, c("PC1", "PC2", "PC3", "PC4"))
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1, groups = ir.species,
choices = c(x_index, y_index), varname.size = 4)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', legend.position = 'top')
print(g)
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(ggbiplot)
# Define UI
ui <- fluidPage(
titlePanel("PCA Visualization"),
sidebarLayout(
sidebarPanel(
fileInput("file", "Upload Data"),
checkboxInput("log_transform", "Log Transform Input Data", value = TRUE),
selectInput("xpc", "Choose X Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC1"),
selectInput("ypc", "Choose Y Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC2")
),
mainPanel(
tabsetPanel(
tabPanel("PCA Plot", plotOutput("pca_plot")),
tabPanel("Result Data", tableOutput("result_data")),
tabPanel("Input Data (Log)", tableOutput("input_data")),
tabPanel("Extended Results", verbatimTextOutput("extended_results"))
)
)
)
)
# Define server
server <- function(input, output) {
# Load data
data <- reactive({
req(input$file)
read.csv(input$file$datapath)
})
# Log transform data
log.data <- reactive({
if (input$log_transform) {
log(data())
} else {
data()
}
})
# Apply PCA
ir.pca <- reactive({
prcomp(log.data(), center = TRUE, scale. = TRUE)
})
# Create plot
output$pca_plot <- renderPlot({
x_index <- match(input$xpc, c("PC1", "PC2", "PC3", "PC4"))
y_index <- match(input$ypc, c("PC1", "PC2", "PC3", "PC4"))
g <- ggbiplot(ir.pca(), obs.scale = 1, var.scale = 1,
choices = c(x_index, y_index), varname.size = 4)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', legend.position = 'top')
print(g)
})
# Display result data
output$result_data <- renderTable({
as.data.frame(ir.pca()$x)
})
# Display input data
output$input_data <- renderTable({
data()
})
# Display extended results
output$extended_results <- renderPrint({
summary(ir.pca())
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(ggbiplot)
# Define UI
ui <- fluidPage(
titlePanel("PCA Visualization"),
sidebarLayout(
sidebarPanel(
checkboxInput("log_transform", "Log Transform Input Data", value = TRUE),
selectInput("xpc", "Choose X Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC1"),
selectInput("ypc", "Choose Y Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC2")
),
mainPanel(
tabsetPanel(
tabPanel("PCA Plot", plotOutput("pca_plot")),
tabPanel("Result Data", tableOutput("result_data")),
tabPanel("Input Data (Log)", tableOutput("input_data")),
tabPanel("Extended Results", verbatimTextOutput("extended_results"))
)
)
)
)
# Define server
server <- function(input, output) {
# Load data
data <- iris[, 1:4]
# Log transform data
log.data <- reactive({
if (input$log_transform) {
log(data)
} else {
data
}
})
# Apply PCA
ir.pca <- reactive({
prcomp(log.data(), center = TRUE, scale. = TRUE)
})
# Create plot
output$pca_plot <- renderPlot({
x_index <- match(input$xpc, c("PC1", "PC2", "PC3", "PC4"))
y_index <- match(input$ypc, c("PC1", "PC2", "PC3", "PC4"))
g <- ggbiplot(ir.pca(), obs.scale = 1, var.scale = 1,
choices = c(x_index, y_index), varname.size = 4)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', legend.position = 'top')
print(g)
})
# Display result data
output$result_data <- renderTable({
as.data.frame(ir.pca()$x)
})
# Display input data
output$input_data <- renderTable({
log.data()
})
# Display extended results
output$extended_results <- renderPrint({
summary(ir.pca())
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(shiny)
library(ggbiplot)
# Define UI
ui <- fluidPage(
titlePanel("PCA Visualization"),
sidebarLayout(
sidebarPanel(
selectInput("xpc", "Choose X Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC1"),
selectInput("ypc", "Choose Y Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC2")
),
mainPanel(
tabsetPanel(
tabPanel("PCA Plot", plotOutput("pca_plot")),
tabPanel("Result Data", tableOutput("result_data")),
tabPanel("Input Data (Log)", tableOutput("input_data")),
tabPanel("Extended Results", verbatimTextOutput("extended_results"))
)
)
)
)
# Define server
server <- function(input, output) {
# Load data
data(iris)
log.ir <- log(iris[, 1:4])
ir.species <- iris[, 5]
# Apply PCA
ir.pca <- prcomp(log.ir, center = TRUE, scale. = TRUE)
# Create plot
pca_plot <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1, groups = ir.species)
pca_plot <- pca_plot + theme(legend.direction = 'horizontal', legend.position = 'top')
output$pca_plot <- renderPlot({
x_index <- match(input$xpc, c("PC1", "PC2", "PC3", "PC4"))
y_index <- match(input$ypc, c("PC1", "PC2", "PC3", "PC4"))
g <- pca_plot +
geom_point(aes_string(x = paste0("PC", x_index), y = paste0("PC", y_index)),
color = "black")
print(g)
})
# Display result data
output$result_data <- renderTable({
as.data.frame(ir.pca$x)
})
# Display input data
output$input_data <- renderTable({
log.ir
})
# Display extended results
output$extended_results <- renderPrint({
summary(ir.pca)
})
}
# Run the application
shinyApp(ui = ui, server = server)
runApp('PCA可選擇1234.R')
library(shiny)
library(ggbiplot)
# Define UI
ui <- fluidPage(
titlePanel("PCA Visualization"),
sidebarLayout(
sidebarPanel(
selectInput("pc", "Choose Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC1")
),
mainPanel(
plotOutput("pca_plot"),
tableOutput("result_data"),
tableOutput("input_data"),
verbatimTextOutput("extended_results")
)
)
)
# Define server
server <- function(input, output) {
# Load data
data(iris)
log.ir <- log(iris[, 1:4])
ir.species <- iris[, 5]
# Apply PCA
ir.pca <- prcomp(log.ir, center = TRUE, scale. = TRUE)
# Create plot
output$pca_plot <- renderPlot({
x_index <- match(input$pc, c("PC1", "PC2", "PC3", "PC4"))
y_index <- match(input$pc, c("PC1", "PC2", "PC3", "PC4"))
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1, groups = ir.species,
choices = c(x_index, y_index), varname.size = 4)
g <- g + scale_color_manual(values = unique(ir.species))
g <- g + theme(legend.direction = 'horizontal', legend.position = 'top')
print(g)
})
# Display result data
output$result_data <- renderTable({
as.data.frame(ir.pca$x)
})
# Display input data
output$input_data <- renderTable({
iris
})
# Display extended results
output$extended_results <- renderPrint({
summary(ir.pca)
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(ggbiplot)
# Define UI
ui <- fluidPage(
titlePanel("PCA Visualization"),
sidebarLayout(
sidebarPanel(
selectInput("xpc", "Choose X Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC1"),
selectInput("ypc", "Choose Y Principal Component:",
choices = c("PC1", "PC2", "PC3", "PC4"),
selected = "PC2")
),
mainPanel(
tabsetPanel(
tabPanel("PCA Plot", plotOutput("pca_plot")),
tabPanel("Result Data", tableOutput("result_data")),
tabPanel("Input Data (Log)", tableOutput("input_data")),
tabPanel("Extended Results", verbatimTextOutput("extended_results"))
)
)
)
)
# Define server
server <- function(input, output) {
# Load data
data(iris)
log.ir <- log(iris[, 1:4])
ir.species <- iris[, 5]
# Apply PCA
ir.pca <- prcomp(log.ir, center = TRUE, scale. = TRUE)
# Create plot
output$pca_plot <- renderPlot({
x_index <- match(input$xpc, c("PC1", "PC2", "PC3", "PC4"))
y_index <- match(input$ypc, c("PC1", "PC2", "PC3", "PC4"))
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1, groups = ir.species,
choices = c(x_index, y_index), varname.size = 4)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', legend.position = 'top')
print(g)
})
# Display result data
output$result_data <- renderTable({
as.data.frame(ir.pca$x)
})
# Display input data
output$input_data <- renderTable({
log.ir
})
# Display extended results
output$extended_results <- renderPrint({
summary(ir.pca)
})
}
# Run the application
shinyApp(ui = ui, server = server)
runApp('PCA可選擇1234.R')
data(iris)
# log transform
log.ir <- log(iris[, 1:4])
ir.species <- iris[, 5]
# apply PCA - scale. = TRUE is highly advisable, but default is FALSE.
ir.pca <- prcomp(log.ir,center = TRUE, scale. = TRUE)
library(ggbiplot)
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1, groups = ir.species)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', legend.position = 'top')
print(g)
runApp('完整版PCA網頁呈現.R')
library(shiny)
library(ggbiplot)
library(cluster)
# Define UI
ui <- fluidPage(
titlePanel("Clustering Analysis"),
sidebarLayout(
sidebarPanel(
selectInput("method", "Choose Clustering Method:",
choices = c("K-Means")),
sliderInput("clusters", "Number of Clusters:",
min = 1, max = 10, value = 3),
selectInput("xvar", "Choose X Variable:",
choices = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width"),
selected = "Sepal.Length"),
selectInput("yvar", "Choose Y Variable:",
choices = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width"),
selected = "Sepal.Width")
),
mainPanel(
tabsetPanel(
tabPanel("Scatter Plot", plotOutput("scatter_plot")),
tabPanel("Cluster Plot", plotOutput("cluster_plot")),
tabPanel("Cluster Data", tableOutput("cluster_data"))
)
)
)
)
# Define server
server <- function(input, output) {
# Load data
data(iris)
iris.sub <- iris[, c(input$xvar, input$yvar)]
# Perform clustering
cluster.output <- reactive({
switch(input$method,
"K-Means" = kmeans(iris.sub, input$clusters))
})
# Create scatter plot
output$scatter_plot <- renderPlot({
ggplot(iris.sub, aes_string(x = input$xvar, y = input$yvar)) +
geom_point()
})
# Create cluster plot
output$cluster_plot <- renderPlot({
iris.sub$cluster <- as.factor(cluster.output()$cluster)
ggbiplot(iris.sub, obs.scale = 1, var.scale = 1,
groups = iris.sub$cluster)
})
# Display cluster data
output$cluster_data <- renderTable({
cbind(iris, cluster.output()$cluster)
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(ggplot2)
# Define UI
ui <- fluidPage(
titlePanel("Cluster Analysis"),
sidebarLayout(
sidebarPanel(
selectInput("xvar", "X Variable:",
choices = colnames(iris)[1:4],
selected = colnames(iris)[1]),
selectInput("yvar", "Y Variable:",
choices = colnames(iris)[1:4],
selected = colnames(iris)[2]),
numericInput("k", "Number of Clusters:", 3, min = 1, max = 10, step = 1),
checkboxInput("log_transform", "Log Transform Input Data", value = FALSE)
),
mainPanel(
tabsetPanel(
tabPanel("Scatter Plot", plotOutput("scatter_plot")),
tabPanel("Cluster Results", tableOutput("cluster_results"))
)
)
)
)
# Define server
server <- function(input, output) {
# Load data
data(iris)
data <- iris
# Log transform data
log.data <- reactive({
if (input$log_transform) {
log(data[, 1:4])
} else {
data[, 1:4]
}
})
# Run k-means
cluster <- reactive({
kmeans(log.data(), centers = input$k)
})
# Create scatter plot
output$scatter_plot <- renderPlot({
ggplot(data, aes_string(x = input$xvar, y = input$yvar, color = factor(cluster()$cluster))) +
geom_point(size = 3) +
scale_color_discrete(name = "Cluster") +
labs(x = input$xvar, y = input$yvar, title = "Scatter Plot with Cluster Labels")
})
# Display cluster results
output$cluster_results <- renderTable({
cluster()$centers
})
}
# Run the application
shinyApp(ui = ui, server = server)
